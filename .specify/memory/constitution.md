# Physical AI Todo Application - Constitution
**Version**: 1.0.0
**Ratified**: 2025-12-04
**Author**: Alishba Fatima
**Repository**: https://github.com/AlishbaFatima12/physical-ai-todo

---

## Purpose

This constitution governs the development of the Physical AI Todo Application across **5 evolutionary phases**, from a simple console app to a cloud-native AI-powered platform. It ensures:

- **Spec-Driven Development**: Every feature begins with a specification. Code generation via Claude Code only.
- **Phase-Correct Evolution**: Each phase builds on the previous without breaking changes.
- **Quality Standards**: 80%+ test coverage, comprehensive documentation, clean architecture.
- **Strategic Bonus Implementation**: Reusable intelligence, cloud-native blueprints, multi-language, voice commands.

**Core Constraint**: You **CANNOT write code manually**. You **MUST** refine specifications until Claude Code generates the correct output via `/sp.implement`.

---

## Core Principles

### I. Spec-Driven Development (MANDATORY - ZERO TOLERANCE)

**Every line of code MUST be generated by Claude Code via specifications. No exceptions.**

#### The Spec-First Rule
1. **Before ANY code**: Create specification via `/sp.specify`
2. **Before ANY implementation**: Create plan via `/sp.plan`
3. **Before ANY coding session**: Create tasks via `/sp.tasks`
4. **Code generation ONLY**: Use `/sp.implement` to generate code
5. **Refinement Loop**: If code is incorrect â†’ Refine spec â†’ Re-run `/sp.implement`

#### Prohibited Actions
- âŒ Writing code directly in `.py`, `.tsx`, `.ts` files
- âŒ Manual edits to generated code (except configuration files)
- âŒ Copy-pasting code from external sources
- âŒ Implementing features without approved specs

#### Allowed Actions
- âœ… Writing specifications in `specs/<feature>/spec.md`
- âœ… Writing plans in `specs/<feature>/plan.md`
- âœ… Writing tasks in `specs/<feature>/tasks.md`
- âœ… Refining specs based on generated code review
- âœ… Configuration files (`.env`, `docker-compose.yml`, `kubernetes/*.yaml`)
- âœ… Documentation files (`README.md`, ADRs, PHRs)

#### Specification Quality Requirements
Every spec MUST include:
- **User Story**: As a [role], I want [feature] so that [benefit]
- **Acceptance Criteria**: Observable, verifiable outcomes (Given/When/Then format)
- **Dependencies**: What must exist before this feature
- **Test Cases**: Minimum 3 test scenarios (happy path, edge cases, error cases)
- **Non-Functional Requirements**: Performance, security, UX constraints
- **API Contracts**: Input/output schemas for all interfaces

#### The Refinement Loop
```
1. Write Spec â†’ Approve
2. Generate Plan â†’ Approve
3. Generate Tasks â†’ Approve
4. Run /sp.implement â†’ Review Generated Code
5. If INCORRECT:
   â”œâ”€ Identify gaps in spec
   â”œâ”€ Refine spec with MORE detail
   â”œâ”€ Re-approve spec
   â””â”€ Re-run /sp.implement
6. If CORRECT:
   â”œâ”€ Run tests
   â”œâ”€ Commit changes
   â””â”€ Create PHR
```

**Maximum 3 refinement iterations per feature**. If failing after 3 iterations, break down into smaller features.

### II. Phase-Correct Evolution (NO PREMATURE FEATURES)

**Deliver each phase completely before starting the next. Architecture must support evolution without rewrites.**

Each phase has:
- **Defined scope**: Specific features to implement
- **Technology additions**: New tools/frameworks introduced
- **Architecture evolution**: How system structure changes
- **Data model extensions**: New fields/tables added
- **Backward compatibility**: Previous phase features continue working

---

## Phase I: In-Memory Python Console App
**Scope**: Basic CRUD operations in console interface

### Phase I Feature Scope (5 Features)

#### âœ… Must Implement (Basic Level)
1. **Add Task** - Create new todo items with title and description
2. **View Task List** - Display all tasks in console
3. **Update Task** - Modify existing task details (title, description)
4. **Delete Task** - Remove tasks from the list
5. **Mark as Complete** - Toggle task completion status

#### âŒ Must NOT Implement in Phase I
- âŒ Priorities & Tags (Phase II)
- âŒ Search & Filter (Phase II)
- âŒ Sort Tasks (Phase II)
- âŒ Recurring Tasks (Phase III)
- âŒ Due Dates & Reminders (Phase III)
- âŒ Web interface (Phase II)
- âŒ Database (Phase II)
- âŒ AI chatbot (Phase III)

### Phase I Technology Stack
- **Language**: Python 3.13+
- **CLI Framework**: `argparse` (standard library)
- **Storage**: In-memory (Python `list` of `dict`)
- **Testing**: `unittest` (standard library)
- **Dependencies**: ZERO external dependencies for core logic

### Phase I Data Model
```python
# In-memory storage: List[Dict]
{
    "id": int,            # Auto-generated, sequential (1, 2, 3, ...)
    "title": str,         # Required, max 200 chars
    "description": str,   # Optional, max 2000 chars
    "completed": bool,    # Default False
    "created_at": str     # ISO 8601 timestamp (datetime.now().isoformat())
}
```

### Phase I Architecture
```
src/
â”œâ”€â”€ todo/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py          # CLI entry point (argparse)
â”‚   â”œâ”€â”€ storage.py      # In-memory CRUD operations
â”‚   â””â”€â”€ models.py       # Task validation and business logic
â””â”€â”€ tests/
    â”œâ”€â”€ test_storage.py # Unit tests for storage
    â””â”€â”€ test_cli.py     # Integration tests for CLI
```

### Phase I Success Criteria
- âœ… All 5 basic features working in console
- âœ… 80%+ test coverage (unittest)
- âœ… Zero external dependencies for core logic
- âœ… All specs, plans, tasks documented in `specs/phase-1/`
- âœ… All PHRs created in `history/prompts/phase-1/`
- âœ… README.md with installation and usage instructions

### Phase I Bonus Feature: Reusable Intelligence (Foundation)
Create **Claude Code Subagents** for:
1. **Spec Generator Agent** - Generates boilerplate specs from user stories
2. **Test Generator Agent** - Generates unittest test cases from specs
3. **Refactoring Agent** - Improves code quality without behavior changes

Store in: `.claude/agents/`

---

## Phase II: Full-Stack Web Application
**Scope**: Web interface + Database + Intermediate features

### Phase II Feature Scope

#### âœ… Must Implement (Intermediate Level)
6. **Priorities** - Assign High/Medium/Low priority to tasks
7. **Tags/Categories** - Multi-tag support (e.g., "work", "urgent", "personal")
8. **Search Tasks** - Full-text search across title and description
9. **Filter Tasks** - By completion status, priority, tags
10. **Sort Tasks** - By due date, priority, created date, alphabetical

#### âœ… Must Migrate from Phase I
- All 5 basic features (Add, View, Update, Delete, Mark Complete)
- Migrate in-memory data model to SQLModel/Postgres
- Maintain backward compatibility (same task structure)

### Phase II Technology Stack

#### Backend
- **Framework**: FastAPI 0.100+
- **ORM**: SQLModel (Pydantic + SQLAlchemy)
- **Database**: Neon Postgres (serverless, cloud-native)
- **Validation**: Pydantic v2
- **Testing**: pytest (upgrade from unittest)

#### Frontend
- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript
- **UI Library**: shadcn/ui (Radix UI + Tailwind CSS)
- **State Management**: React Query (TanStack Query)
- **API Client**: fetch API with TypeScript types

### Phase II Data Model Evolution
```python
# SQLModel schema (compatible with Phase I model)
class Task(SQLModel, table=True):
    id: int = Field(default=None, primary_key=True)
    title: str = Field(max_length=200, index=True)
    description: str = Field(default="", max_length=2000)
    completed: bool = Field(default=False, index=True)
    created_at: datetime = Field(default_factory=datetime.now)

    # NEW in Phase II
    priority: str = Field(default="medium")  # "high", "medium", "low"
    tags: str = Field(default="[]")  # JSON array stored as string
    updated_at: datetime = Field(default_factory=datetime.now)
```

### Phase II Architecture
```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py           # FastAPI application
â”‚   â”œâ”€â”€ models.py         # SQLModel schemas
â”‚   â”œâ”€â”€ crud.py           # Database operations
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ routes/
â”‚   â”‚       â””â”€â”€ tasks.py  # REST API endpoints
â”‚   â””â”€â”€ core/
â”‚       â”œâ”€â”€ config.py     # Settings (Neon DB connection)
â”‚       â””â”€â”€ database.py   # SQLModel engine
â””â”€â”€ tests/
    â”œâ”€â”€ test_crud.py
    â””â”€â”€ test_api.py

frontend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ page.tsx          # Home page (task list)
â”‚   â”œâ”€â”€ layout.tsx        # Root layout
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ TaskList.tsx
â”‚       â”œâ”€â”€ TaskForm.tsx
â”‚       â”œâ”€â”€ TaskFilters.tsx
â”‚       â””â”€â”€ TaskItem.tsx
â””â”€â”€ lib/
    â”œâ”€â”€ api.ts            # API client functions
    â””â”€â”€ types.ts          # TypeScript types
```

### Phase II Migration Strategy
1. **Keep Phase I code**: Preserve `src/todo/` as reference
2. **Create new structure**: `backend/` and `frontend/` directories
3. **Data migration**: Write migration script `scripts/migrate_phase1_to_phase2.py`
4. **API compatibility**: FastAPI endpoints mirror Phase I CLI commands
5. **Parallel testing**: Ensure Phase I tests still pass with new backend

### Phase II Success Criteria
- âœ… All 10 features working (5 basic + 5 intermediate)
- âœ… Web UI with responsive design
- âœ… Neon Postgres integration
- âœ… 80%+ test coverage (pytest)
- âœ… API documentation (FastAPI auto-generated Swagger)
- âœ… All specs, plans, tasks documented in `specs/phase-2/`

### Phase II Bonus Feature: Reusable Intelligence (Expansion)
Add **Agent Skills**:
1. **FastAPI CRUD Generator** - Generates boilerplate CRUD routes
2. **Next.js Component Generator** - Generates React components from specs
3. **Migration Generator** - Auto-generates Alembic migrations

Store in: `.claude/skills/`

---

## Phase III: AI-Powered Todo Chatbot
**Scope**: Conversational AI interface + Advanced features

### Phase III Feature Scope

#### âœ… Must Implement (Advanced Level)
11. **Recurring Tasks** - Auto-reschedule repeating tasks (daily, weekly, monthly)
12. **Due Dates** - Date/time pickers for deadlines
13. **Time Reminders** - Browser notifications before due date

#### âœ… Must Implement (AI Integration)
14. **Natural Language Interface** - "Add task: Buy groceries tomorrow at 2pm"
15. **Intelligent Rescheduling** - "Reschedule my morning meetings to 2 PM"
16. **Task Suggestions** - AI suggests priorities, tags, due dates based on patterns

### Phase III Technology Stack

#### AI Components (NEW)
- **Chat Interface**: OpenAI ChatKit
- **Agent Framework**: OpenAI Agents SDK
- **Tool Integration**: Official MCP SDK (Model Context Protocol)
- **LLM**: OpenAI GPT-4 Turbo

#### Backend Extensions
- **Job Scheduler**: APScheduler (recurring tasks)
- **Notifications**: WebSockets (real-time browser notifications)
- **AI Router**: LangChain or direct OpenAI API

#### Frontend Extensions
- **Chat UI**: shadcn/ui chat components
- **Notifications**: react-toastify + browser Notification API
- **Date Pickers**: react-datepicker

### Phase III Data Model Evolution
```python
class Task(SQLModel, table=True):
    # ... Phase I & II fields ...

    # NEW in Phase III
    due_date: datetime | None = Field(default=None, index=True)
    recurrence: str | None = Field(default=None)  # JSON: {"type": "daily", "interval": 1}
    reminder_minutes: int = Field(default=0)  # 0 = no reminder, 15 = 15 min before
    ai_suggested_priority: str | None = Field(default=None)
    ai_suggested_tags: str = Field(default="[]")
```

### Phase III Architecture
```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ ai/
â”‚   â”‚   â”œâ”€â”€ chatbot.py        # OpenAI ChatKit integration
â”‚   â”‚   â”œâ”€â”€ agents.py         # OpenAI Agents SDK setup
â”‚   â”‚   â”œâ”€â”€ mcp_tools.py      # MCP SDK tool definitions
â”‚   â”‚   â””â”€â”€ prompts.py        # System prompts for AI
â”‚   â”œâ”€â”€ jobs/
â”‚   â”‚   â””â”€â”€ scheduler.py      # APScheduler for recurring tasks
â”‚   â””â”€â”€ websockets/
â”‚       â””â”€â”€ notifications.py  # Real-time notifications
â””â”€â”€ tests/
    â”œâ”€â”€ test_ai.py
    â””â”€â”€ test_scheduler.py

frontend/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ chat/
â”‚       â””â”€â”€ page.tsx          # Chat interface page
â””â”€â”€ components/
    â”œâ”€â”€ ChatInterface.tsx
    â”œâ”€â”€ MessageList.tsx
    â””â”€â”€ TaskSuggestions.tsx
```

### Phase III AI Capabilities
1. **Natural Language Task Creation**
   - Input: "Add task: Buy groceries tomorrow at 2pm with high priority"
   - AI parses: title, due_date, priority
   - Creates task via MCP tools

2. **Intelligent Rescheduling**
   - Input: "Reschedule my morning meetings to 2 PM"
   - AI identifies tasks with "meeting" and time < 12pm
   - Updates due_date to 2pm

3. **Context-Aware Suggestions**
   - AI analyzes task patterns
   - Suggests priorities based on due dates
   - Suggests tags based on similar tasks

### Phase III Success Criteria
- âœ… All 13 features working (10 from Phase I-II + 3 advanced)
- âœ… Conversational chatbot interface
- âœ… Natural language task management
- âœ… Recurring tasks auto-scheduling
- âœ… Browser notifications working
- âœ… 80%+ test coverage
- âœ… All specs, plans, tasks documented in `specs/phase-3/`

### Phase III Bonus Features
1. **Multi-language Support (Urdu)**
   - Add Urdu translations for chatbot
   - Use i18n for UI strings
   - Store in `backend/app/i18n/ur.json` and `frontend/locales/ur.json`

2. **Voice Commands**
   - Add voice input for chatbot
   - Use Web Speech API (browser) or speech_recognition (Python)
   - Commands: "Add task...", "Show my tasks", "Mark complete..."

---

## Phase IV: Local Kubernetes Deployment
**Scope**: Containerization + Local K8s orchestration

### Phase IV Technology Stack (NEW)
- **Containerization**: Docker + Docker Compose
- **Orchestration**: Kubernetes (Minikube for local)
- **Package Manager**: Helm (custom charts)
- **AI Tooling**: kubectl-ai (natural language K8s), kagent (AI K8s agent)
- **Service Mesh**: Istio or Linkerd (optional)

### Phase IV Architecture
```
kubernetes/
â”œâ”€â”€ charts/
â”‚   â””â”€â”€ physical-ai-todo/
â”‚       â”œâ”€â”€ Chart.yaml
â”‚       â”œâ”€â”€ values.yaml
â”‚       â””â”€â”€ templates/
â”‚           â”œâ”€â”€ deployment.yaml
â”‚           â”œâ”€â”€ service.yaml
â”‚           â”œâ”€â”€ ingress.yaml
â”‚           â”œâ”€â”€ configmap.yaml
â”‚           â””â”€â”€ secret.yaml
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ backend.Dockerfile
â”‚   â””â”€â”€ frontend.Dockerfile
â””â”€â”€ scripts/
    â”œâ”€â”€ deploy-local.sh
    â””â”€â”€ test-deployment.sh
```

### Phase IV Deployment Components
1. **Backend Service** - FastAPI in container
2. **Frontend Service** - Next.js in container
3. **Database** - Neon Postgres (external, not containerized)
4. **AI Service** - Separate container for OpenAI integrations
5. **Job Scheduler** - APScheduler in sidecar container

### Phase IV Success Criteria
- âœ… All services containerized (multi-stage Docker builds)
- âœ… Helm chart deploying to Minikube
- âœ… All features working on local K8s
- âœ… kubectl-ai integration for management
- âœ… Health checks and readiness probes
- âœ… 80%+ test coverage (integration tests in K8s)
- âœ… All specs, plans, tasks documented in `specs/phase-4/`

### Phase IV Bonus Feature: Cloud-Native Blueprints
Create **Agent Skills for K8s**:
1. **Helm Chart Generator** - Generates Helm charts from specs
2. **Dockerfile Generator** - Auto-generates optimized Dockerfiles
3. **K8s Manifest Generator** - Creates deployment manifests

Store in: `.claude/skills/cloud-native/`

---

## Phase V: Advanced Cloud Deployment
**Scope**: Production cloud deployment + Event-driven architecture

### Phase V Technology Stack (NEW)
- **Cloud Provider**: DigitalOcean Kubernetes (DOKS)
- **Event Streaming**: Apache Kafka
- **Microservices Runtime**: Dapr (Distributed Application Runtime)
- **Observability**: Prometheus + Grafana + Jaeger
- **CI/CD**: GitHub Actions + ArgoCD

### Phase V Architecture (Event-Driven)
```
Services:
1. Task Service (FastAPI) - CRUD operations
2. AI Service (FastAPI) - Chatbot and suggestions
3. Notification Service (FastAPI) - Email/browser notifications
4. Scheduler Service (Python) - Recurring tasks

Event Flow:
TaskCreated â†’ Kafka â†’ AI Service (suggest priority/tags)
TaskDuesSoon â†’ Kafka â†’ Notification Service (send reminder)
RecurrenceTriggered â†’ Kafka â†’ Task Service (create new instance)
```

### Phase V Dapr Components
```
dapr/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ pubsub.yaml        # Kafka pub/sub
â”‚   â”œâ”€â”€ statestore.yaml    # Redis for Dapr state
â”‚   â””â”€â”€ secrets.yaml       # Vault or K8s secrets
â””â”€â”€ configurations/
    â””â”€â”€ tracing.yaml       # Jaeger configuration
```

### Phase V Success Criteria
- âœ… Deployed to DigitalOcean DOKS
- âœ… Event-driven architecture with Kafka
- âœ… Dapr integration for pub/sub, state, secrets
- âœ… Observability stack (metrics, logs, traces)
- âœ… CI/CD pipeline (GitHub Actions â†’ ArgoCD)
- âœ… Production-grade security (TLS, secrets management)
- âœ… All specs, plans, tasks documented in `specs/phase-5/`

### Phase V Bonus Feature: Cloud-Native Blueprints (Advanced)
Add **Advanced Agent Skills**:
1. **Dapr Component Generator** - Auto-generates Dapr YAML configs
2. **Kafka Topic Manager** - Creates and manages Kafka topics
3. **ArgoCD Application Generator** - GitOps application manifests

Store in: `.claude/skills/cloud-native/advanced/`

---

## Feature Levels (Implementation Across Phases)

### Basic Level (Core Essentials) - Phase I
Foundation features, quick to build, essential for MVP:
1. **Add Task** - Create new todo items
2. **Delete Task** - Remove tasks from list
3. **Update Task** - Modify existing task details
4. **View Task List** - Display all tasks
5. **Mark as Complete** - Toggle completion status

### Intermediate Level (Organization & Usability) - Phase II
Make the app polished and practical:
6. **Priorities** - Assign levels (high/medium/low)
7. **Tags/Categories** - Labels for organization (work/home/personal)
8. **Search & Filter** - Search by keyword; filter by status, priority, date
9. **Sort Tasks** - Reorder by due date, priority, or alphabetically

### Advanced Level (Intelligent Features) - Phase III
10. **Recurring Tasks** - Auto-reschedule repeating tasks (e.g., "weekly meeting")
11. **Due Dates & Time Reminders** - Set deadlines with date/time; browser notifications

---

## Project Structure (All Phases)

```
physical-ai-todo/
â”œâ”€â”€ .specify/
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â””â”€â”€ constitution.md          # This file
â”‚   â”œâ”€â”€ templates/                    # Spec-Kit Plus templates
â”‚   â””â”€â”€ scripts/                      # Automation scripts
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ commands/                     # Slash commands
â”‚   â”œâ”€â”€ agents/                       # Reusable subagents (Bonus)
â”‚   â””â”€â”€ skills/                       # Reusable skills (Bonus)
â”œâ”€â”€ specs/
â”‚   â”œâ”€â”€ phase-1/                      # Phase I specs
â”‚   â”œâ”€â”€ phase-2/                      # Phase II specs
â”‚   â”œâ”€â”€ phase-3/                      # Phase III specs
â”‚   â”œâ”€â”€ phase-4/                      # Phase IV specs
â”‚   â””â”€â”€ phase-5/                      # Phase V specs
â”œâ”€â”€ history/
â”‚   â”œâ”€â”€ prompts/                      # PHRs per phase
â”‚   â””â”€â”€ adr/                          # Architecture Decision Records
â”œâ”€â”€ src/                              # Phase I: Console app
â”‚   â”œâ”€â”€ todo/
â”‚   â””â”€â”€ tests/
â”œâ”€â”€ backend/                          # Phase II+: FastAPI backend
â”‚   â”œâ”€â”€ app/
â”‚   â””â”€â”€ tests/
â”œâ”€â”€ frontend/                         # Phase II+: Next.js frontend
â”‚   â”œâ”€â”€ app/
â”‚   â””â”€â”€ components/
â”œâ”€â”€ kubernetes/                       # Phase IV+: K8s configs
â”‚   â”œâ”€â”€ charts/
â”‚   â””â”€â”€ docker/
â”œâ”€â”€ dapr/                             # Phase V: Dapr configs
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/                    # CI/CD (Phase V)
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ package.json
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ README.md
â””â”€â”€ CLAUDE.md
```

---

## Specification Standards

### Every Feature Specification Must Include

#### 1. Header
```markdown
# Feature: [Feature Name]
**Phase**: [I/II/III/IV/V]
**Priority**: [High/Medium/Low]
**Dependencies**: [List of prerequisite features]
```

#### 2. User Story
```markdown
## User Story
As a [role],
I want [feature],
So that [benefit].
```

#### 3. Acceptance Criteria (Given/When/Then)
```markdown
## Acceptance Criteria

### Scenario 1: [Happy Path]
- **Given** [initial context]
- **When** [action occurs]
- **Then** [expected outcome]

### Scenario 2: [Edge Case]
...

### Scenario 3: [Error Case]
...
```

#### 4. API Contract (if applicable)
```markdown
## API Contract

### Endpoint
`POST /api/tasks`

### Request
```json
{
  "title": "string (max 200)",
  "description": "string (max 2000, optional)",
  "priority": "high|medium|low (optional, default: medium)"
}
```

### Response (200 OK)
```json
{
  "id": 123,
  "title": "string",
  ...
}
```

### Errors
- 400 Bad Request: Invalid input
- 500 Internal Server Error: Database error
```

#### 5. Test Cases
```markdown
## Test Cases

### Unit Tests
1. `test_create_task_with_valid_data_returns_task`
2. `test_create_task_with_empty_title_raises_error`
3. `test_create_task_with_long_title_truncates`

### Integration Tests
1. `test_api_create_task_returns_201`
2. `test_api_create_task_persists_to_database`
```

#### 6. Non-Functional Requirements
```markdown
## Non-Functional Requirements
- **Performance**: API response < 200ms (p95)
- **Security**: Input validation, SQL injection prevention
- **UX**: Form validation with inline errors
```

---

## Testing Standards

### Coverage Requirements
- **Minimum**: 80% line coverage (all phases)
- **Target**: 90%+ for core business logic
- **Measurement**: `pytest --cov` or `coverage.py`

### Test Pyramid Distribution
- 70% Unit Tests (fast, isolated, mocked dependencies)
- 20% Integration Tests (medium speed, real database/API calls)
- 10% E2E Tests (slow, full user workflows)

### Test Naming Convention
```python
def test_<function>_<scenario>_<expected_outcome>():
    """Test that <function> <scenario> results in <expected outcome>"""
```

Examples:
- `test_add_task_with_valid_data_creates_task()`
- `test_add_task_with_empty_title_raises_ValueError()`
- `test_search_tasks_with_no_results_returns_empty_list()`

### Test Structure (Arrange-Act-Assert)
```python
def test_example():
    # Arrange: Set up test data and dependencies
    storage = TaskStorage()
    task_data = {"title": "Test Task"}

    # Act: Execute the functionality being tested
    result = storage.add_task(task_data)

    # Assert: Verify expected outcomes
    assert result["id"] is not None
    assert result["title"] == "Test Task"
```

---

## Architecture Decision Records (ADRs)

### When to Create ADR
Use the **three-part test** - ALL must be true:
1. **Impact**: Long-term consequences (framework, data model, API, security, platform)
2. **Alternatives**: Multiple viable options with different tradeoffs
3. **Scope**: Cross-cutting, influences system design

### ADR Examples for This Project
- âœ… **Phase I â†’ II Migration Strategy** (rewrite vs refactor vs parallel)
- âœ… **Storage Backend Choice** (SQLite vs Postgres vs MongoDB)
- âœ… **AI Framework Selection** (OpenAI Agents vs LangChain vs custom)
- âœ… **K8s Packaging** (Helm vs Kustomize vs raw YAML)
- âœ… **Event Streaming** (Kafka vs RabbitMQ vs Redis Streams)

### ADR Suggestion Format
```
ğŸ“‹ Architectural decision detected: [brief-description]
   Document reasoning and tradeoffs? Run `/sp.adr [decision-title]`
```

**Never auto-create ADRs. Always wait for user consent.**

---

## Prompt History Records (PHRs)

### PHR Creation (MANDATORY)
Create PHR after:
- âœ… Every feature implementation
- âœ… Every planning session
- âœ… Every debugging session
- âœ… Every spec/plan/task creation
- âœ… Every phase completion

Skip PHR for:
- âŒ Simple status queries
- âŒ `/sp.phr` command itself

### PHR Routing (All under `history/prompts/`)
- Constitution: `history/prompts/constitution/`
- Phase-specific: `history/prompts/phase-<N>/`
- Feature-specific: `history/prompts/phase-<N>/<feature-name>/`
- General: `history/prompts/general/`

### PHR File Naming
```
<ID>-<slug>.<stage>.prompt.md

Examples:
001-setup-phase-1.constitution.prompt.md
042-add-task-feature.green.prompt.md
103-deploy-to-doks.misc.prompt.md
```

---

## Bonus Features Strategy

### Bonus 1: Reusable Intelligence
**Goal**: Create reusable Claude Code subagents and skills across all phases

**Deliverables**:
1. **Subagents** (`.claude/agents/`)
   - Spec Generator Agent
   - Test Generator Agent
   - Refactoring Agent

2. **Agent Skills** (`.claude/skills/`)
   - FastAPI CRUD Generator
   - Next.js Component Generator
   - Migration Generator
   - Helm Chart Generator
   - Dockerfile Generator

**Implementation Timeline**:
- Phase I: Foundation (Spec Generator, Test Generator)
- Phase II: Web skills (CRUD Generator, Component Generator)
- Phase III: Complete (Refactoring Agent)
- Phase IV-V: Advanced (Cloud skills)

### Bonus 2: Cloud-Native Blueprints
**Goal**: Agent skills for Kubernetes and cloud-native patterns

**Deliverables**:
1. **K8s Skills** (`.claude/skills/cloud-native/`)
   - Helm Chart Generator
   - Dockerfile Generator (multi-stage, optimized)
   - K8s Manifest Generator

2. **Dapr Skills** (`.claude/skills/cloud-native/advanced/`)
   - Dapr Component Generator
   - Kafka Topic Manager
   - ArgoCD Application Generator

**Implementation Timeline**:
- Phase IV: K8s skills
- Phase V: Dapr skills

### Bonus 3: Multi-language Support (Urdu)
**Goal**: Urdu language support in chatbot

**Deliverables**:
1. Translation files (`backend/app/i18n/ur.json`, `frontend/locales/ur.json`)
2. Chatbot understands Urdu input
3. UI switches between English and Urdu

**Implementation Timeline**:
- Phase III: Complete

### Bonus 4: Voice Commands
**Goal**: Voice input for todo operations

**Deliverables**:
1. Voice input in chatbot (Web Speech API)
2. Voice commands: "Add task...", "Show tasks", "Mark complete..."
3. Fallback to text if voice fails

**Implementation Timeline**:
- Phase III: Complete

---

## Development Workflow (Spec-Driven)

### For Every Feature
1. **Specify** (`/sp.specify`)
   - Create `specs/phase-N/<feature-name>/spec.md`
   - Get user approval

2. **Plan** (`/sp.plan`)
   - Create `specs/phase-N/<feature-name>/plan.md`
   - Identify ADRs if needed
   - Get user approval

3. **Tasks** (`/sp.tasks`)
   - Create `specs/phase-N/<feature-name>/tasks.md`
   - Break into â‰¤30 min tasks
   - Get user approval

4. **Implement** (`/sp.implement`)
   - Generate code via Claude Code
   - **NO manual coding**
   - If incorrect â†’ Refine spec â†’ Re-implement

5. **Test**
   - Run test suite
   - Verify 80%+ coverage
   - All tests pass

6. **Commit** (`/sp.git.commit_pr`)
   - Commit with descriptive message
   - Reference spec/task IDs

7. **Record** (`/sp.phr`)
   - Create Prompt History Record
   - Document learnings

### Refinement Loop (If Generated Code is Incorrect)
```
1. Review generated code
2. Identify what's wrong
3. Identify gaps in spec (missing detail, unclear requirements)
4. Refine spec with MORE specificity
5. Re-approve spec
6. Re-run /sp.implement
7. Repeat max 3 times
8. If still failing â†’ Break feature into smaller pieces
```

---

## Quality Gates (Per Phase)

### Phase Completion Checklist
Before completing each phase:

- [ ] All features for this phase implemented
- [ ] All features from previous phases still working
- [ ] 80%+ test coverage
- [ ] All tests passing
- [ ] All specs documented in `specs/phase-N/`
- [ ] All PHRs created in `history/prompts/phase-N/`
- [ ] README.md updated with phase-specific instructions
- [ ] No manual code (all via `/sp.implement`)

### Code Quality Standards
- **Linting**: Pass `flake8` (Python), `eslint` (TypeScript)
- **Formatting**: `black` (Python), `prettier` (TypeScript)
- **Type Safety**: Type hints (Python), strict TypeScript
- **Documentation**: Docstrings (Python), JSDoc (TypeScript)

---

## Human as Tool Strategy

### Invocation Triggers
1. **Ambiguous Requirements**: Ask 2-3 clarifying questions
2. **Unforeseen Dependencies**: Surface and ask for prioritization
3. **Architectural Uncertainty**: Present options with pros/cons
4. **Completion Checkpoints**: Summarize and confirm next steps

### Example Interactions
```
â“ Clarification: Should recurring tasks create new instances or update existing?
  A) New instance each recurrence (preserve history)
  B) Update existing task (less clutter)

â“ Dependency: Search requires full-text indexing. Options:
  A) Simple LIKE queries (fast, less accurate)
  B) Postgres full-text search (slower, more powerful)
  C) External search engine (complex, best quality)

âœ… Phase I Complete: All 5 basic features working, 95% test coverage.
   Ready to start Phase II (web app + database)?
```

---

## Governance

### Constitution Authority
- This constitution **supersedes all other practices**
- All work MUST comply with this constitution
- Amendments require user approval

### Compliance Verification
- Every PR: Verify spec exists and was approved
- Every commit: Verify code generated via `/sp.implement`
- Every phase: Verify quality gates pass

### Amendment Process
1. Identify need for change
2. Create ADR documenting rationale
3. Update constitution
4. Get user approval
5. Increment version (MAJOR.MINOR.PATCH)

---

## Quick Reference

### Slash Commands
- `/sp.constitution` - Update this constitution
- `/sp.specify` - Create feature specification
- `/sp.plan` - Create architectural plan
- `/sp.tasks` - Break down into tasks
- `/sp.implement` - Generate code (ONLY way to write code)
- `/sp.git.commit_pr` - Commit and create PR
- `/sp.phr` - Create Prompt History Record
- `/sp.adr` - Create Architecture Decision Record
- `/sp.clarify` - Ask clarifying questions
- `/sp.analyze` - Cross-artifact consistency check

### File Locations
- Constitution: `.specify/memory/constitution.md`
- Specs: `specs/phase-<N>/<feature>/spec.md`
- Plans: `specs/phase-<N>/<feature>/plan.md`
- Tasks: `specs/phase-<N>/<feature>/tasks.md`
- PHRs: `history/prompts/phase-<N>/`
- ADRs: `history/adr/`

### Phase Progression
- **Phase I**: Console app (5 basic features, in-memory)
- **Phase II**: Web app (add 5 intermediate features, Postgres)
- **Phase III**: AI chatbot (add 3 advanced features, OpenAI)
- **Phase IV**: Local K8s (containerize, Minikube, Helm)
- **Phase V**: Cloud production (DOKS, Kafka, Dapr)

---

**Version**: 1.0.0
**Ratified**: 2025-12-04
**Last Amended**: 2025-12-04

**Remember**: You CANNOT write code manually. Refine specs until Claude Code generates correct output via `/sp.implement`. This is the essence of Spec-Driven Development.
